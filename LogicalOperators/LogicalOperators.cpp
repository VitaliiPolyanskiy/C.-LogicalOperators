#include <iostream>
using namespace std;

int main()
{
	// К логическим операторам относятся следующие операторы:
	// Логическое отрицание  !(унарный).
	// Логическое И  && (бинарный).
	// Логическое ИЛИ  || (бинарный).

	bool a, b;
	cout << "a\t|" << "b\t|" << "a && b\t|" << "a || b\t|" << "!a" << endl;
	cout << "-------------------------------------------" << endl;

	a = false;
	b = false;
	cout << boolalpha;
	cout << a << "\t|" << b << "\t|" << (a && b) << "\t|" << (a || b) << "\t|" << !a << endl;

	a = false;
	b = true;
	cout << a << "\t|" << b << "\t|" << (a && b) << "\t|" << (a || b) << "\t|" << !a << endl;

	a = true;
	b = false;
	cout << a << "\t|" << b << "\t|" << (a && b) << "\t|" << (a || b) << "\t|" << !a << endl;

	a = true;
	b = true;
	cout << a << "\t|" << b << "\t|" << (a && b) << "\t|" << (a || b) << "\t|" << !a << endl;

	// Операторы логическое И и логическое ИЛИ работают по сокращенной схеме. Это означает, что если 
	// левый операнд логического И будет ЛОЖЬ, то проверка правого операнда осуществляться не будет. 
	// Ну а при использовании логического ИЛИ, если левый операнд окажется ИСТИНОЙ, то правый операнд 
	// также проверяться не будет. Из-за этого могут возникнуть определенные логические ошибки.

	int nValue1 = 1;
	int nValue2 = 1;

	bool result = ++nValue1 > 0 || ++nValue2 > 0;
	cout << "Result = " << result << endl;

	cout << "nValue1 = " << nValue1 << endl;
	cout << "nValue2 = " << nValue2 << endl;

	// В вышеприведенном примере значение переменной nValue2 не изменилось, потому что операция 
	// инкрементирования не выполнилась, так как сработала сокращенная схема оператора ||, то есть 
	// левый операнд оказался ИСТИННЫМ, следовательно, какой бы ни был правый операнд, оператор || в 
	// любом случае вернет ИСТИНУ.

	nValue1 = 1;
	nValue2 = 1;

	result = --nValue1 > 0 && --nValue2 > 0;
	cout << "Result = " << result << endl;

	cout << "nValue1 = " << nValue1 << endl;
	cout << "nValue2 = " << nValue2 << endl;

	// В вышеприведенном примере, значение переменной nValue2 не изменилось, потому что операция 
	// декрементирования не выполнилась, так как сработала сокращенная схема оператора &&, то есть 
	// левый операнд оказался ЛОЖНЫМ, следовательно, какой бы ни был правый операнд, оператор && в 
	// любом случае вернет ЛОЖЬ.

	return 0;
}